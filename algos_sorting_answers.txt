1. Write pseudocode for bubble sort.
  FUNCTION bubbleSort(collection)
    REPEAT
      SET swapped to false

      FOR i = FIRST INDEX of collection to LAST INDEX of collection - 1

        IF collection[i] > collection[i + 1] THEN
          SET tmp to collection[i]
          SET collection[i] to collection[i + 1]
          SET swapped to true
        END IF
      END FOR
    UNTIL swapped is FALSE

    RETURN collection
  END FUNCTION

2. Write pseudocode for quicksort.

  FUNCTION quicksort(left, right, pivot)
    SET pivot to last item of the collection
    SET left to left side of pivot
    SET right to right side of pivot

    WHILE pivot
      IF left > pivot
        THEN swap left and pivot
      ELSE

      END IF
    END WHILE
  END FUNCTION

3. We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. After looking at the pseudocode for the above sorting
methods, identify why merge sort and quick sort are much more efficient than the others. Walking through each algorithm with a few sample collections may help.


4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is the ideal input for bucket sort?
  Bucket sort works by distributing the elements in an array into buckets. This allows the buckets to be sorted individually (which can be done either by sorting the buckets
  individually with a different sorting algorithm, or by using the algorithm recursively). There are a few instances in which we would want to implement bucket sort, but in
  general it has to be applied when we are able to find the index of specific items. It is also commonly used when input is uniformly distributed over a range.
