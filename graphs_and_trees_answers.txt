1. What is a binary tree and what makes it unique to other trees?
  A binary tree is a data structure that has the option to have a left child and a right child coming from the root node at the top, but can only have two children. It
  is also sorted by value, where any nodes with a value less than the root node would go on one side of the tree, and any nodes with a value greater than the root node
  would go on the other side of the tree.

2. What is a heuristic?
  A heuristic is basically a best guess approach to finding all possible paths, where an algorithm will make guesses but it won't be 100% accurate.

3. What is another problem besides the shortest-path problem that requires the use of heuristics?
  Another problem besides the shortest-path problem that could require the use of heuristics would be playing a game, such as chess or checkers. Even
  though an algorithm could calculate every possible move available, it would be easier for it to narrow it down and make guesses so to speak.

4. What is the difference between a depth-first search and a breadth-first search?
  A depth-first search will start on one branch and go through that branch before reversing back to others. A breadth-first search will start with the root
  node and then search within the nodes on the next level first before continuing to the level below.

5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.
  An undirected, a-cyclic, unweighted graph is a graph that does not have a direct start and end location at a node, has nodes that do not form loops, and
  does not assign the cost of travel between it's nodes.

6. What kind of graph is a binary search tree?
  A binary search tree is an directed, a-cyclic, unweighted node.


1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.
Example: The value 10 exists in the tree. The value 23 does not exist in the tree.

  class Node {
    constructor(data, left = null, right = null) {
      this.data = data;
      this.left = left;
      this.right = right;
    }
  }

  class BinarySearchTree {
    constructor() {
      this.root = null;
    }
    add(data) {
      const node = this.root;
      if (node === null) {
        this.root = new Node(data);
        return;
      } else {
        const searchTree = function(node) {
        if (data < node.data) {
          if (node.left === null) {
            node.left = new Node(data);
            return;
          } else if (node.left !== null) {
            return searchTree(node.left);
          }
        } else if (data > node.data) {
          if (node.right === null) {
            node.right = new Node(data);
            return;
            } else if (node.right !== null) {
              return searchTree(node.right);
            }
          } else {
          return null;
        }
      };
      return searchTree(node);
    }
  }
  isPresent(data) {
    let current = this.root;
    while (current) {
      if (data === current.data) {
        return 'The value exists in the binary tree.';
      }
      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    return 'The value does not exist in the binary tree.';
    }
  }

  var bst = new BinarySearchTree();
  bst.add(1);
  bst.add(2);
  bst.add(3);
  bst.add(9);
  bst.add(15);
  console.log(bst.isPresent(15));
  console.log(bst.isPresent(5));

2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.
Example: The distance between the nodes 4 and 10 is 4. The distance between the nodes 8 and 10 is 1. The distance between the nodes 1 and 14 is 4.
